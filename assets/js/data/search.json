[ { "title": "The Straw That Broke The Scripts Block", "url": "/posts/The-Straw-That-Broke-The-Scripts-Block/", "categories": "PowerShell", "tags": "PowerShell,, InjectionHunter,, macOS,, Windows,, Visual, Studio, Code,, characterset", "date": "2018-09-04 00:00:00 -0700", "snippet": "This is a reminder to be mindful when copying and pasting code from an external source. I’ve been putting InjectionHunter to use and encountered “the straw that broke the camel’s back script’s block.” It shows how well designed this module is (thanks @Lee_Holmes!) Straw Script block part of the decrement operator -- a for() loop I decided to give InjectionHunter a whirl against a script module I wrote for Wirecast on macOS, but my playground for this was my Windows laptop with a current version of the module. Out of many, many script files, three items came up with the Severity of “Warning” and it ended with a ParseException. Really? InjectionHunter is bugged! Nope.The ParseException was thrown once InjectionHunter hit a script file, Start-Countdown.ps1 (it counts backwards based on the time you specify):There were a few errors after this but for brevity sake, only the first one is shown here.This ParseError was obviously pointing to one or more conflicting characters but the strange thing was that this script has been used in production for quite a while and has never thrown exceptions like this; it just worked as expected.Opening the script file in Visual Studio Code (in Windows), I found the straw. Glancing at the for() loop on line 28 (as per the ParseException) didn’t offer an obvious clue because everything appeared correct. But honing in on the decrement operator, the left “-“ is slightly longer in size than the right “-“:Copying and pasting into Notepad reflects the same thing:It reminds me of the auto-formatting of hyphens in Microsoft Word when hitting a space afterwards. Clearly, there is no space added here.By replacing this conflicting character with the correct one (manual typing), InjectionHunter completes without throwing the ParseException:No more ParseException! With the correct-size straw, this camel script block can now function without a grunt.So, whether you’re following someone else’s work or you copy/paste from an external source, always make sure the correct character set is used, and if you use InjectionHunter, maybe it will find anomalies like it did here." }, { "title": "Converting Celsius to Fahrenheit Vice Versa", "url": "/posts/Converting-Celsius-to-Fahrenheit-Vice-Versa/", "categories": "PowerShell", "tags": "PowerShell,, temperature, conversion", "date": "2018-08-30 00:00:00 -0700", "snippet": "There are a few ways to converting Celsius to Fahrenheit, vice-versa, but here is a simple, advanced function that can do it for you.Simply enter the known degrees in the -Value parameter then specify what you want to convert to:-Celsius or -FahrenheitConvert-Temperature -Value 33 -FahrenheitThe example above would return 91.4 Fahrenheit based on the -Value 33.BEGIN {} BlockThis function supports pipeline input. Instead of checking if -Celsius or -Farhenheit was specified each time an object is processed in the PROCESS{} block, we do only one check in the BEGIN{} block (before any objects are processed in the pipeline).Based on the switch specified (-Celsius or -Fahrenheit), we assign its corresponding mathematical formula with a placeholder (tempValue) to a variable, called $formula. This variable is of type String so that we can do a Replace() on tempValue for the actual Value.PROCESS {} BlockAs each Value in the pipeline is processed, the tempValue placeholder is replaced by the current Value object. This is done using Replace() as stated earlier.Finally, Invoke-Expression is used to invoke the formula as a mathematical expression (instead of a string), and the result converted to a double with rounding.Note: error handling has been left out intentionally:Function Convert-Temperature { &amp;lt;# .SYNOPSIS Converts between Celsius and Fahrenheit. .DESCRIPTION Converts temperatures between Celsius and Fahrenhiet, vice-versa. .PARAMETER Celsius Converts the Value to Celsius. .PARAMETER Fahrenheit Coverts the Value to Fahrenheit. #&amp;gt; [CmdletBinding()] param ( [Parameter( Mandatory, Position = 0, ValueFromPipeline = $true)] [double[]] $Value, [Parameter(ParameterSetName = &#39;Celsius&#39;)] [switch] $Celsius, [Parameter(ParameterSetName = &#39;Fahrenheit&#39;)] [switch] $Fahrenheit ) BEGIN { # Store the formula in memory before any objects are processed if ($Fahrenheit.IsPresent) { [string]$formula = &quot;(( 9 * tempValue) / 5) + 32&quot; } else { [string]$formula = &quot;(5 * (tempValue - 32)) / 9&quot; } } PROCESS { foreach ($temperature in $Value) { [double]$result = Invoke-Expression (($formula).Replace(&#39;tempValue&#39;, $temperature)) [double]$roundedResult = [System.Math]::Round($result, 2) Write-Output $roundedResult } }}" }, { "title": "PowerShell Core Get TCP Connections on macOS", "url": "/posts/PowerShell-Core-Get-TCP-Connections-on-macOS/", "categories": "PowerShell", "tags": "PowerShell, Core,, tcp,, macOS,, lsof", "date": "2018-07-09 00:00:00 -0700", "snippet": "Getting active TCP connections can tell about what might be going on between applications and systems, and even help with network troubleshooting. As of PowerShell Core 6.0.2, there is no built-in cmdlet for getting TCP connections (unlike in Windows PowerShell - Get-NetTCPConnection) but with a little work, we can author our own function to get similar information on macOS.Scroll down to see the entire script, or continue reading to understand each component.Step 1 - Use bash to get TCP connectionsThe first step is to use a bash command that will get TCP connections and then assign it to a variable, $connCommand. This is accomplished by using lsof and grep:$connCommand = &#39;lsof -i -P | grep -i &quot;ESTABLISHED&quot;&#39;Command explained:lsof is a Unix command that lists all open files and the processes that opened them-i lists IP sockets-P indicates that port numbers should be used and not the port names| pipes lsof output to the grep commandgrep is a command for Unix-like OSes that searches plain text datasets that match a regular expression-i indicates to ignore case&quot;Established&quot; is the regular expression we’re looking to matchStep 2 - Use Invoke-ExpressionWe can use Invoke-Expression to execute the code in $connCommand which will return a collection of objects; let’s use a variable for that collection, $tcpConnection:$tcpConnection = Invoke-Expression -Command $connCommandStep 3 - Use foreach to Build ObjectsNext, iterate through the $tcpConnection collection and use the -split operator to split at any one (or more) whitespace characters into separate objects. For this function, we want the 9 properties that the bash command returns, so the output needs 9 “splits”:foreach ($conn in $tcpConnection) { $data = $conn -split &#39;s+&#39;, 9 ... # more code to come}Still inside the foreach loop, we use a $props variable to reference a hashtable consisting of the 9 properties and their values and then create a new PSObject using $props:$props = @{ Command = $data[0] PID = $data[1] User = $data[2] FD = $data[3] Type = $data[4] Device = $data[5] SizeOffset = $data[6] Node = $data[7] Name = $data[8]} New-Object -TypeName psobject -Property $props }If you were to run the bash command lsof -i -P by itself without piping to grep , it would output a table with headers in this order: Command, PID, User, FD, Type, Device, SizeOffset, Node, and Name; hence, the order of properties in the $props hashtable.That’s it for the “piece by piece” approach. Now, for the entire thing in one function:Function Get-TCPConnection { &amp;lt;# .SYNOPSIS Gets established TCP network connections. .DESCRIPTION Gets established TCP network connections. .EXAMPLE PS /&amp;gt; Get-TCPConnection SizeOffset : 0t0 Device : 0x95a801d5eeaa641 PID : 715 FD : 72u Type : IPv4 Node : TCP Command : firefox User : MacUser Name : 10.0.3.30:65323-&amp;gt;23.100.72.34:443 (ESTABLISHED) The example above lists one of many (truncated output) established TCP connections. .INPUTS None .OUTPUTS System.Management.Automation.PSCustomObject #&amp;gt; [CmdletBinding()] param () $connCommand = &#39;lsof -i -P | grep -i &quot;ESTABLISHED&quot;&#39; $tcpConnection = Invoke-Expression -Command $connCommand foreach ($conn in $tcpConnection) { $data = $conn -split &#39;s+&#39;, 9 $props = @{ Command = $data[0] PID = $data[1] User = $data[2] FD = $data[3] Type = $data[4] Device = $data[5] SizeOffset = $data[6] Node = $data[7] Name = $data[8] } New-Object -TypeName psobject -Property $props }}Copy the entire function into the PowerShell console and run it:PS /&amp;gt; Get-TCPConnectionSizeOffset : 0t0FD : 3uCommand : DesktopUser : ahardyDevice : 0x95a801d5eea9381Type : IPv4PID : 386Name : localhost:49183-&amp;gt;localhost:13823 (ESTABLISHED)Node : TCPSizeOffset : 0t0FD : 57uCommand : firefoxUser : ahardyDevice : 0x95a801d5c388901Type : IPv4PID : 31155Name : macbookpro:56558-&amp;gt;ip-198-71-233-204.ip.secureserver.net:80 (ESTABLISHED)Node : TCPAnd that’s all there is to it.Hopefully, you will find this simple function useful to get active TCP connections on your computer. This is an interim solution until an official cmdlet is added to PowerShell Core." }, { "title": "OpenSSH Remoting Broken After PowerShell Upgrade", "url": "/posts/OpenSSH-Remoting-Broken-After-PowerShell-Upgrade/", "categories": "PowerShell", "tags": "PowerShell, Core,, remoting,, Win32_OpenSSH,, macOS,, Windows,, PSSessionOpenFailed", "date": "2018-06-05 00:00:00 -0700", "snippet": "PowerShell Remoting in PowerShell Core has transformed the way Windows can communicate with other operating systems like Linux and macOS, and accomplish tasks using PowerShell and Bash as though you’re physically present on that disparate system. This has been accomplished by combining PowerShell Core and the Win32 port of OpenSSH.Because following the Microsoft Docs step-by-step does work (in my many experiences), this post will not discuss the setup of Win32_OpenSSH. Rather, it will focus on when upgrading PowerShell Core (on macOS and/or Windows) causes Win32_OpenSSH to break and return errors upon trying to connect to remote Windows computers.ScenarioYou just updated PowerShell Core on Windows and/or macOS from 6.0.x to 6.0.2. Perhaps you did this manually or by using a package manager like Chocolatey or Homebrew. You try to connect to remote computers using a PowerShell session; after supplying the prompt with a password, you are greeted with an error message:PS /Users/aarontheadmin&amp;gt; $s = New-PSSession -HostName paw-01 -UserName aarontheadmin -SSHTransport aarontheadmin@paw-01&#39;s password: New-PSSession : [paw-01] The SSH client session has ended with error message: The SSH transport process has abruptly terminated causing this remote session to break. At line:1 char:6 + $s = New-PSSession -HostName paw-01 -UserName aarontheadmin -SSHTransport + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OpenError: (System.Manageme....RemoteRunspace:RemoteRunspace) [New-PSSession], PSRemotingTransportException + FullyQualifiedErrorId : PSSessionOpenFailedNow, let’s look into a solution to fix this problem!SolutionWhat has been the common fix for me? A reinstall? No. Update the sshd_config file and restart the services/daemons.The initial setup of OpenSSH requires a Subsystem entry for PowerShell in the sshd_config file. There are two items that need to be updated: Version number (in the path) The path to PowerShell (pwsh)In Windows: Go to C:\\ProgramData\\ssh Open sshd_config (may need to copy to Desktop for editing, then copy back) Near end of document, an entry for powershell should match as follows:Subsystem powershell C:/Program Files/PowerShell/6/pwsh.exe -sshs -NoLogo -NoProfile Make necessary changes and save the file (copy back to C:\\ProgramData\\ssh if copying from Desktop). In PowerShell, run Restart-Service sshd, ssh-agentIn macOS: Open Terminal Using your favorite editor, edit the sshd_config file: sudo nano /private/etc/ssh/sshd_config Near end of document, an entry for PowerShell should match as follows: Subsystem powershell /usr/local/bin/pwsh -sshs -NoLogo -NoProfile Save changes and exit the editor. Using Terminal, restart the OpenSSH daemon: sudo launchctl stop com.openssh.sshd sudo launchctl start com.openssh.sshdIt can be very inconvenient but sometimes removing all public keys and/or the known_hosts file can dissolve many issues.Wrapping UpBy following these steps and ensuring the correct information exists in the OpenSSH configuration on Windows and/or macOS, a lot of connectivity issues can be fixed and your PowerShell remoting back in business!" }, { "title": "iTunes Cleanup Library and Music Media", "url": "/posts/iTunes-Cleanup-Library-and-Music-Media/", "categories": "PowerShell", "tags": "PowerShell, Core,, iTunes,, macOS", "date": "2018-05-18 00:00:00 -0700", "snippet": "I’ve been writing a PowerShell module that handles the automation of live streaming on an iMac running macOS 10.13 using Wirecast, iTunes and some other tools.One of requirements is that the iTunes music library and any associated music media files are automatically deleted once iTunes has done its part. The use of iTunes for just anything is restricted in this environment, so deleting everything in it is safe.IMPORTANT: This script completely removes the iTunes Library.itl file. All data in your iTunes Library will be deleted.Here is the script that takes care of everything:Function Invoke-iTunesCleanup { [CmdletBinding( SupportsShouldProcess = $true, ConfirmImpact = &#39;High&#39; )] param () $iTunesPath = &quot;/Users/$env:USER/Music/iTunes&quot; $ilt = &#39;iTunes Library.itl&#39; $iTunesLibrary = Join-Path -Path $iTunesPath -ChildPath $ilt $MusicPath = &#39;iTunes Media/Music&#39; $iTunesMusic = Join-Path -Path $iTunesPath -ChildPath $MusicPath if ($PSCmdlet.ShouldProcess(&quot;iTunes&quot;)) { # Delete the entire Music folder try { Remove-Item -Path $iTunesMusic -Recurse -Force -ErrorAction Stop Write-Host &quot;Deleted $iTunesMusic&quot; -ForegroundColor Green $completed = $true } catch { Write-Host &quot;Could not delete $iTunesMusic&quot; -ForegroundColor Red } # Delete the iTunes .itl file that contains library info try { Remove-Item -Path $iTunesLibrary -Force -ErrorAction Stop Write-Host &quot;Deleted $iTunesLibrary&quot; -ForegroundColor Green $completed = $true } catch { Write-Host &quot;Could not delete $iTunesLibrary&quot; -ForegroundColor Red } if ($completed) { Write-Host &quot;iTunes cleanup complete.&quot; -ForegroundColor Green } }}You may need to close and re-open iTunes to see the music library empty. Also, confirm that /Users/username/Music/iTunes/iTunes Media/Music no longer exists (this is where the music media files were stored).You can enhance this script by parameterizing the paths but being targeted for iTunes, the paths shouldn’t really change." }, { "title": "Netstat as PowerShell Objects to Identify Port Usage", "url": "/posts/Netstat-as-PowerShell-Objects-to-Identify-Port-Usage/", "categories": "PowerShell", "tags": "Windows, PowerShell,, netstat,, Windows", "date": "2018-04-04 00:00:00 -0700", "snippet": "This post covers how to dump netstat output into Windows PowerShell objects for easier management and investigation purposes. This can be helpful if you’re trying to find out what port is being used with a given IP address on current TCP connections.You can use netstat to report TCP connections including the ports and PIDs but not the process name associated with the PID. And, the output is ugly and doesn’t offer much flexibility.A solution is to wrap netstat in a PowerShell command so that it can also report the process name bound to a given port:Function Get-TCPPortConnection { [CmdletBinding()] param ( [Parameter(Mandatory)] [uint16] $Port = 80 ) $NetStatCmd = netstat -ano | findstr :$Port $NetStatCmd | ConvertFrom-String -PropertyName Null, Protocol, LocalAddress, ForeignAddress, State, PID | Select-Object -Property Protocol, LocalAddress, ForeignAddress, State, PID, @{ Name = &#39;ProcessName&#39;; Expression = { Get-Process -PID $_.PID | Select-Object -ExpandProperty ProcessName } }}This code snippet will take the output of netstat and turn it into PowerShell objects. It includes the actual process name so you don’t have to manually cross-reference the PID. This makes it much easier to find out what port is being used and where." }, { "title": "Update PowerShell Core and dotnet Core Packages Using Homebrew", "url": "/posts/Update-PowerShell-Core-and-dotnet-Core-Packages-Using-Homebrew/", "categories": "PowerShell", "tags": "PowerShell, Core,, dotnetcore,, Homebrew,, upgrade,, macOS", "date": "2018-03-18 00:00:00 -0700", "snippet": "With the recent CVE bulletin, Microsoft Security Advisory CVE-2018-0875: Hash Collision can cause Denial of Service, it warrants us to update PowerShell Core to 6.0.2 and .NET Core to 2.0.6.This post covers updating PowerShell Core and .NET Core packages using Homebrew, the Microsoft-recommend method for installing/managing these packages. This method can be used any time you want to update either package: Open Terminal. Run brew update (It will appear nothing is happening but watch the window title bar) Run brew cask upgrade powershell Run brew cask upgrade dotnet Once completed, run pwsh to load PowerShell. You should see 6.0.2 (or the newest version) at the top:PowerShell v6.0.2Copyright (c) Microsoft Corporation. All rights reserved.https://aka.ms/pscore6-docsType &#39;help&#39; to get help.PS /&amp;gt; You can also confirm by using $PSVersionTable:PS /&amp;gt; $PSVersionTable Name Value ---- ----- PSVersion 6.0.2 PSEdition Core GitCommitId v6.0.2 OS Darwin 17.4.0 Darwin Kernel Version 17.4.0: S...Platform Unix PSCompatibleVersions {1.0, 2.0, 3.0, 4.0...} PSRemotingProtocolVersion 2.3 SerializationVersion 1.1.0.1 WSManStackVersion 3.0Now, run dotnet –info  (two dashes) and you should see Version 2.0.6:PS /Users/aarontheadmin&amp;gt; dotnet --info Microsoft .NET Core Shared Framework Host Version : 2.0.6 Build : 74b1c703813c8910df5b96f304b0f2b78cdf194dYour packages are officially updated." }, { "title": "Double Click command File to Execute PowerShell Core Script", "url": "/posts/Double-Click-command-File-to-Execute-PowerShell-Core-Script/", "categories": "PowerShell", "tags": "PowerShell, Core,, .command,, bash,, macOS", "date": "2018-03-09 00:00:00 -0800", "snippet": "Sometimes, double-clicking a file on the desktop to execute a script makes it much more convenient to accomplish something, even though it has its security implications. This post covers how to do that with Powershell Core and .commands files in macOS.Note: To accomplish this in PowerShell Core 6.0.1+ is different that PowerShell Core 6.0.0. We’ll go with PowerShell Core 6.0.1.Simply create a new file ending in .command. This could be placed on the desktop.At the beginning of the file, you need to start with the command keyword. This will be followed by the commands you want to execute, and any arguments. It’s helpful to clear any output on the console, so we’ll throw in the clear command:command clearNext, add &amp;amp;&amp;amp; which is used to execute the next operation if the previous one completed successfully:command clear &amp;amp;&amp;amp;Now, specify the PowerShell Core command, pwsh, so that it executes next:command clear &amp;amp;&amp;amp; pwshNow the fun part, appending the actual PowerShell code. Use the -Command parameter to tell PowerShell, “I have a command you need to execute,” rather than a file (-File).The entire command is enclosed in double-quotes. Inside the double-quotes, you use the invoke operator ( &amp;amp; ), followed by a set of curly braces ( { } ) wherein you place your actual PowerShell code:command clear &amp;amp;&amp;amp; pwsh -command &quot;&amp;amp;{ Get-Process }&quot;Save your file and double-click it!You can also try some other cmdlets or functions of your own inside the curly braces:command clear &amp;amp;&amp;amp; pwsh -Command &quot;&amp;amp; { Get-Random Get-Process}&quot;Executing this (truncated) code returns:1969584494Verb AliasPrefix Group Description ---- ----------- ----- ----------- Add a Common Adds a resource to a container, or at...Clear cl Common Removes all the resources from a cont...Close cs Common Changes the state of a resource to ma...Copy cp Common Copies a resource to another name or ...Enter et Common Specifies an action that allows the u...Exit ex Common Sets the current environment or conte...Find fd Common Looks for an object in a container th...Format f Common Arranges objects in a specified form ...Now you can double-click a .command file to execute a PowerShell script!" }, { "title": "PowerShell Core Fixing path not found of Mounted SMB in macOS", "url": "/posts/PowerShell-Core-Fixing-path-not-found-of-Mounted-SMB-in-macOS/", "categories": "PowerShell", "tags": "PowerShell, Core,, macos,, smb,, path, not, found,, mount", "date": "2018-03-01 00:00:00 -0800", "snippet": "Automation on the Mac is great, when it works. And it can, in this case. In this post, we’ll cover an issue where scripts resolving SMB paths fail with the ‘path not found’ error message, yet those same shares ARE accessible within the GUI. Confusing and frustrating? This is critical if you’re trying to automate data transfers to network locations using SMB.The ProblemI’ve been working in a Mac environment where an Ant script transfers data to an SMB share on a local Windows server.Sometimes, the Ant script would fail to transfer the data to the SMB share, and report “path not found”. However, the share was mounted on the desktop, and one could access and modify data without any issues.Re-running the Ant script could have happened all day, but it would still fail. Remounting the share did not fix it either. Further down will explain why.As a workaround, I instructed our team to restart into “Safe Boot” to clear the system cache, which worked for a time until the issue resurfaced.Explaining the FixThere are different ways to deal with SMB shares but I haven’t come across a “PowerShell Core” resource for doing it. So, let’s dig in.Essentially, the Ant script was hard-coded to look for the actual mount point /Volumes/netShareA to access its child directories, but it couldn’t resolve that path. It appeared that, anywhere in the GUI was able to resolve that path…or so we thought.What’s the difference?By going to Terminal and typing mount, all the volumes mounted on the system are displayed.And, ahah!netShareA existed as an empty folder, AND a share existed with the name netShareA-1. This means the Ant script was looking at the empty folder, likely orphaned after an SMB reconnect. And no matter how many times we remount the share, the Ant script would never work!So, instead of the old share being flushed out of /Volumes/ by the OS, it lingered as an empty directory, causing it to be named netShareA-1 upon re-connection. Restarting in Safe Boot flushed the empty folder out, allowing the native share name to be used, and hence, the Ant script would work.The Solution: 2 PowerShell ScriptsThere are a couple we can work around this: Build two scripts; one for getting mounted volumes and one for getting the SMB shares based on what is mounted (faster response time); Build one script to get only SMB shares by using mount | grep smb  (slightly slower response time)Option 1 will be used to work around this issue until Apple can fix it (fix targeted for macOS 10.12 but it still exists in High Sierra), or the OS flushes its cache.Script 1 - Get-MountedDevicePurpose: Get-MountedDeviceGets everything that is mounted to the system and returns them as PowerShell objects:Function Get-MountedDevice { &amp;lt;# .SYNOPSIS Gets mounted devices. .DESCRIPTION Get-MountedDevice gets all mounted devices connected to the system, including network paths. .INPUTS None. You cannot pipe objects to Get-MountedDevice. .OUTPUTS System.Management.Automation.PSCustomObject. Get-MountedDevice returns a PSCustomObject containing the Device, MountPoint, and FileSystem. .NOTES Author: Aaron Hardy Name: Get-MountedDevice #&amp;gt; [CmdletBinding()] param () # Load all mounted volumes into array. $MountedDevices = @(mount) # Filter used to return only smbfs volumes. $rgxAfterDevice = &#39; on /.*&#39; $rgxBeforeMountPoint = &#39;.* on &#39; $rgxFileSystem = &#39; (.*&#39; foreach ($mntDevice in $MountedDevices) { $Device = $mntDevice -replace $rgxAfterDevice $MountPoint = $mntDevice -replace $rgxBeforeMountPoint -replace $rgxFileSystem $FileSystem = [regex]::matches($mntDevice, $rgxFileSystem).Value $props = @{ Device = $Device.Trim() MountPoint = $MountPoint.Trim() FileSystem = $FileSystem.Trim() } New-Object -TypeName psobject -Property $props }}Script 2 - Get-MacOsSmbSharePurpose: Get-MacOsSmbShareGets the SMB shares with their correct paths and generates them as PowerShell objects:Function Get-MacOsSmbShare { &amp;lt;# .SYNOPSIS Gets SMB shares. .DESCRIPTION Get-MacOsSmbShare gets SMB shares mounted on the local system. .PARAMETER ShareName Specifies the share name to get. .INPUTS None. You cannot pipe objects to Get-MacOsSmbShare. .OUTPUTS System.Management.Automation.PSCustomObject. Get-MacOsSmbShare returns a PSCustomObject containing the Device, MountPoint, and FileSystem. .NOTES Author: Aaron Hardy Name: Get-MountedDevice #&amp;gt; [CmdletBinding()] param ( [Parameter()] [string]$ShareName ) # Filter used to return only smbfs volumes. $rgxVolSmbfs = &#39;(smbfs,&#39; if ($ShareName) { $Share = [regex]::Escape($ShareName) # RegEx to include numerically incremented share names $rgxShareSuffix = &quot;(-(d{1}|d{2}))?$&quot; # Valid path to share in /Volumes $SharePath = &quot;/Volumes/$Share$rgxShareSuffix&quot; $Mounts = Get-MountedDevice | Where-Object -FilterScript { ( $_.FileSystem -match $rgxVolSmbfs ) -and ( $_.MountPoint -match $SharePath) } # Where-Object } else { $Mounts = Get-MountedDevice | Where-Object -FilterScript { ( $_.FileSystem -match $rgxVolSmbfs ) } } # else Write-Output $Mounts | Select-Object -Property MountPoint, Device, FileSystem} # Get-MacOsSmbShareThen to call it in any other script or the pscore command line:PS &amp;gt; (Get-MacOsSmbShare -ShareName netShareA).VolumePath/Volumes/netShareA-1In the case of this example, this would have returned /Volumes/netShareA-1.That’s it!While there is much more that can be done to enhance this script, it has been a great solution to fixing broken SMB paths while using them for automation on a Mac, with no more transfers failing! I hope you can find it just as useful." }, { "title": "Use PowerShell Core in VS Code", "url": "/posts/Use-PowerShell-Core-in-VS-Code/", "categories": "PowerShell", "tags": "Visual, Studio, Code,, terminal.integrated.shell.windows,, pwsh.exe", "date": "2018-02-10 00:00:00 -0800", "snippet": "The movement to PowerShell Core is gaining popularity, along with the wide-spreading use of Visual Studio Code; especially as Microsoft has confirmed Windows PowerShell will no longer have new releases (just support for the current).Here I will show you how to change the PowerShell executable in VS Code (on Windows), under Workspace Settings. Go to View &amp;gt; Command Palette… and select Workspace Settings (note: this will override User Settings) In Search Settings, type .exe Next to “terminal.integrated.shell.windows”:, click the pencil (in whitespace on left) and select Replace in Settings In the right pane, edit the double-quotes to include the path to the PowerShell Core executable (including double backslashes): “terminal.integrated.shell.windows”:”C:\\Program Files\\PowerShell Core[version]\\pwsh.exe” Save and reload VS Code Confirm the PowerShell Core executable is now being used in VS Code (once the terminal finishes loading)That’s it. You are now officially using PowerShell Core to execute your code in Visual Studio Code!Update: In step 6, the default path to PowerShell Core is C:\\Program Files\\PowerShell\\6\\pwsh.exe" }, { "title": "Get Random with Excluded Numbers", "url": "/posts/Get-Random-with-Excluded-Numbers/", "categories": "PowerShell", "tags": "Get-Random,, number, exclusions,, ArrayList,, IndexOf()", "date": "2017-11-13 00:00:00 -0800", "snippet": "An interesting question came up about using the Get-Random cmdlet to return a random number but with a predefined list of numbers to exclude.Even though Get-Random will return a random number, you can also specify a list or range of numbers for it to run against.PS C:\\&amp;gt; Get-Random 1,2,3,4,5…will return a random number between 1 and 5.What if you want to exclude one or more specific numbers? Get-Random doesn’t have this capability built in but we can still accomplish this with a little extra work.Let’s say I want to exclude numbers 1 and 3.Here’s how we’ll do it: Assign the entire range (1 to 5) to an ArrayList Assign the numbers we want to exclude (1 and 3) to another ArrayList Loop through the (second) ArrayList that contains the excluded numbers, and any that match what’s in the first ArrayList, remove it from that ArrayList.This is accomplished by passing the excluded numbers to the IndexOf() method of the first ArrayList object, and invoking it within its RemoveAt() method. The example will shed more light. With the first ArrayList now containing all numbers except for the exclusions, use the result with Get-Random.Here’s the code (see below for explanation):# Create ArrayList for entire range[System.Collections.ArrayList]$NumRange = @(1..5)# Create ArrayList for excluded numbers[System.Collections.ArrayList]$Exclusions = @(1,3)# Loop through excluded numbersforeach ($num in $Exclusions) { # If excluded number exists in entire range, if ($NumRange.Contains($num)) { # remove it from entire range $NumRange.RemoveAt($NumRange.IndexOf($num)) }}Here’s the output:PS C:\\&amp;gt; $NumRange245Now, pipe the results to Get-Random:PS C:\\&amp;gt; $NumRange | Get-Random4There you have it, using Get-Random and a range of numbers with exclusions." }, { "title": "PowerShell Core Updating PSModulePath–from Windows PowerShell PSModulePath", "url": "/posts/PowerShell-Core-Updating-PSModulePath-from-Windows-PowerShell-PSModulePath/", "categories": "PowerShell", "tags": "powershell, core,, psmodulepath", "date": "2017-11-11 00:00:00 -0800", "snippet": "The PowerShell gallery has a script module (credit: Steve Lee [MSFT]) you can install that appends your Windows PSModulePath contents to the PSModulePath in PowerShell Core. This lets you access modules in any of those Windows PSModulePaths within PowerShell Core, including your custom modules.(Note: I’ve already commented on the gallery of what this post will cover. I’ve added it here in case one does not come across the PS Gallery.)This script works but it adds all paths existing in Windows. This causes duplicate paths to exist in PSModulePath in PowerShell Core as some paths already exist in it as well.Here is that script revised so that it adds only paths that don’t exist in PowerShell Core $env:PSModulePath:Function Add-WindowsPSModulePath { if (! $IsWindows) { throw &quot;This cmdlet is only supported on Windows&quot; } $WindowsPSModulePath = [System.Environment]::GetEnvironmentVariable(&quot;psmodulepath&quot;, [System.EnvironmentVariableTarget]::Machine) $WinPaths = ($WindowsPSModulePaths -split &#39;;&#39;) foreach ($path in $WinPaths) { if (-not ($env:PSModulePath).Contains($path)) { $env:PSModulePath += &quot;;$path}&quot; } }}You can copy this code into your profile.ps1 file so it will execute each time you open PowerShell Core:Function Add-WindowsPSModulePath { if (! $IsWindows) { throw &quot;This cmdlet is only supported on Windows&quot; } $WindowsPSModulePath = [System.Environment]::GetEnvironmentVariable(&quot;psmodulepath&quot;, [System.EnvironmentVariableTarget]::Machine) $WinPaths = ($WindowsPSModulePaths -split &#39;;&#39;) foreach ($path in $WinPaths) { if (-not ($env:PSModulePath).Contains($path)) { $env:PSModulePath += &quot;;$path}&quot; } }}Add-WindowsPSModulePath" }, { "title": "Get All Dates In A Given Month", "url": "/posts/Get-All-Dates-In-A-Given-Month/", "categories": "PowerShell", "tags": "powershell,, datetime,, month", "date": "2017-09-11 00:00:00 -0700", "snippet": "This post shows you how to use PowerShell to get actual dates for a given month, not just how many days are in that month.For instance, using the .NET static method [DateTime]::DaysInMonth() only returns the number of days:PS C:\\&amp;gt; [DateTime]::DaysInMonth(2017, 9)30“Great, I know that September has 30 days but I need all the dates so I can check some data against each date of the month. How do I do that?” Let’s take a look.# Declare variables$year, $month = 2017, 9# Get total number of days in the specified month$TotalDays = [DateTime]::DaysInMonth($year, $month)Let’s confirm we have the correct amount of days for September:PS C:\\&amp;gt; $TotalDays30Next, we can pipe each number from 1 to 30 (30 in $TotalDays) to ForEach-Object. Each value (1 through 30) will represent the argument for the -Day parameter as each object passes through the loop:PS C:\\&amp;gt; 1..$TotalDays | ForEach-Object {&amp;gt;&amp;gt; Get-Date -Year $year -Month $month -Day $_ }September 1, 2017 12:00:00 PMSeptember 2, 2017 12:00:00 PMSeptember 3, 2017 12:00:00 PMSeptember 4, 2017 12:00:00 PMSeptember 5, 2017 12:00:00 PMSeptember 6, 2017 12:00:00 PMSeptember 7, 2017 12:00:00 PMSeptember 8, 2017 12:00:00 PMSeptember 9, 2017 12:00:00 PMSeptember 10, 2017 12:00:00 PMSeptember 11, 2017 12:00:00 PMSeptember 12, 2017 12:00:00 PMSeptember 13, 2017 12:00:00 PMSeptember 14, 2017 12:00:00 PMSeptember 15, 2017 12:00:00 PMSeptember 16, 2017 12:00:00 PMSeptember 17, 2017 12:00:00 PMSeptember 18, 2017 12:00:00 PMSeptember 19, 2017 12:00:00 PMSeptember 20, 2017 12:00:00 PMSeptember 21, 2017 12:00:00 PMSeptember 22, 2017 12:00:00 PMSeptember 23, 2017 12:00:00 PMSeptember 24, 2017 12:00:00 PMSeptember 25, 2017 12:00:00 PMSeptember 26, 2017 12:00:00 PMSeptember 27, 2017 12:00:00 PMSeptember 28, 2017 12:00:00 PMSeptember 29, 2017 12:00:00 PMSeptember 30, 2017 12:00:00 PMThere you have it! Now you have all the dates for the month that can be used to pipe to other cmdlets or advanced functions, or whatever else you need to do." } ]
